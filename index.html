<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Framework for generating video</title>

    <!-- Babylon.js -->
    <script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/ammo.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/libktx.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>
    <!-- <script src="https://preview.babylonjs.com/babylon.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs/4.2.0-alpha.13/babylon.max.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>

<body>

    <canvas id="renderCanvas"></canvas>

    <script src="utilities.js"></script>
    <script src="/resources/config/numeros/meshes.js"></script>
    <script src="/resources/config/numeros/init.js"></script>
    <!-- <script src="/resources/config/granja/meshes.js"></script>
    <script src="/resources/config/granja/init.js"></script> -->

    <script>
        var canvas = document.getElementById("renderCanvas");

        // Config environment variables
        var escala = 10;
        var sizeOfWorld = 5000;
        var velocidadDefault = 1;
        var widthDefaultFloor = sizeOfWorld;
        var heightDefaultFloor = sizeOfWorld;

        //Global Variables
        var engine = null;
        var scene = null;
        var sphere = null;
        var dude = null;
        var camera = null;
        var materials = [];
        var mapMeshes = [];
        var meshesLoaded = [];
        var guion = null;
        var vectorCamera = null;
        var positionCameraInitialX, positionCameraInitialY, positionCameraInitialZ = null;

        var startObjectsMovement = false;
        var moveCamera = false;
        var loadCameraMovements = false;

        canvas.addEventListener("keydown", event => {
            //"KeyS"
            if (event.isComposing || event.keyCode === 83) {
                startObjectsMovement = true;
                moveCamera = true;
                loadCameraMovements = true;
            }
            //"KeyP"
            if (event.isComposing || event.keyCode === 80) {
                moveCamera = !moveCamera;
            }
        });

        var createDefaultEngine = function () { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true }); };

        var crearAmbiente = function () {

            scene = new BABYLON.Scene(engine);

            //scene.debugLayer.show();

            // This creates and positions a free camera (non-mesh)
            camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 10, -50), scene);

            // This targets the camera to scene origin
            camera.setTarget(new BABYLON.Vector3(0, 10, 1));

            // This attaches the camera to the canvas
            camera.attachControl(canvas, true);

            //var light = new BABYLON.PointLight("pointLight", new BABYLON.Vector3(1, 10, 1), scene);
            //var light = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(-5, 5, -10), scene);
            var light = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(1,15,1), scene);
            light.diffuse = new BABYLON.Color3(1, 1, 1);

            //const axis = new BABYLON.Debug.AxesViewer();

            // Skybox
            var skybox = createSkybox(scene);

            loadMaterials(materials);
            guion = obtenerGuion();
            mapMeshes = loadMapMeshes();
            mostrarEscenaInicial(guion);

            return scene;
        };

        function mostrarEscenaInicial(guion) {

            //dibujar piso del mundo
            let groundWorld = BABYLON.MeshBuilder.CreateGround("ground of the world", { width: widthDefaultFloor, height: heightDefaultFloor }, scene);
            groundWorld.position.x = 0;
            groundWorld.position.y = -0.1;
            groundWorld.position.z = 0;
            groundWorld.material = materials[guion.materialDefault]

            createRoads(guion, scene);
        }

        function createRoads(guion, scene) {
            for (let index = 0; index < guion.zones.length; index++) {
                const element = guion.zones[index];
                for (let coordX = element.from.coordX; coordX <= element.to.coordX; coordX++) {
                    if (element.gapX == null || mustShowByGap(coordX, element.gapX)) {
                        for (let coordZ = element.from.coordZ; coordZ <= element.to.coordZ; coordZ++) {
                            if (element.gapZ == null || mustShowByGap(coordZ, element.gapZ)) {
                                if (element.mesh != null) {
                                    console.log(element.mesh.model);
                                }
                                crearCeldaCamino(coordX, coordZ, element);
                            }
                        }
                    }
                }
            }
        }

        function mustShowByGap(coord, gap) {
            if (coord == 0) return false;

            if (coord > 0) {
                return ((coord % gap) - 1) == 0;
            }

            if (coord < 0) {
                return (((coord * (-1)) % gap)) == 0;
            }
        }

        function crearCeldaCamino(coordX, coordZ, element) {

            // //Material of cell
            if (element.material != null) {
                //Crear piso
                let ground = BABYLON.MeshBuilder.CreateGround("road:" + coordX + ":" + coordZ, { width: uToPx(1), height: uToPx(1) }, scene);

                //Position of cell
                ground.position.x = centroDeCelda(coordX);
                ground.position.y = 0;
                ground.position.z = centroDeCelda(coordZ);
                ground.material = materials[element.material];
            }

            if (element.mesh != null) {
                let mostrar = true;
                if (element.mesh.probability != null) {
                    let random = Math.random();
                    if (random > (element.mesh.probability / 100)) {
                        mostrar = false;
                    }
                }

                if (mostrar) {
                    meshInstance = loadMesh(element.mesh, coordX, coordZ);
                    return meshInstance;
                }
            }
        }

        function introduccion() {
            engine = createDefaultEngine();
            if (!engine) {
                throw 'engine should not be null.';
            }

            scene = crearAmbiente();

            // Resize
            window.addEventListener("resize", function () {
                engine.resize();
            });

            engine.runRenderLoop(function () {
                if (scene) {

                    nudo();

                    scene.render();
                }
            });
        }

        introduccion();

        function nudo() {

            // Animation of meshes
            for (let index = 0; index < meshesLoaded.length; index++) {
                if (startObjectsMovement && meshesLoaded[index].to) {
                    let meshLoaded = meshesLoaded[index];
                    let velocity = velocidadDefault;
                    for (let j = 0; j < meshLoaded.meshes.length; j++) {
                        //console.log("X - Mesh: %s - Move from %s to %s", meshLoaded.name, scene.meshes[meshLoaded.meshes[j]].position.x, centroDeCelda(meshesLoaded[index].to.coordX));
                        //console.log("Z - Mesh: %s - Move from %s to %s", meshLoaded.name, scene.meshes[meshLoaded.meshes[j]].position.z, centroDeCelda(meshesLoaded[index].to.coordZ));
                        vx = centroDeCelda(meshesLoaded[index].to.coordX) - scene.meshes[meshLoaded.meshes[j]].position.x;
                        vy = 0;
                        vz = centroDeCelda(meshesLoaded[index].to.coordZ) - scene.meshes[meshLoaded.meshes[j]].position.z;

                        let versor = new BABYLON.Vector3(vx, vy, vz).normalize();
                        //console.log(vx + "," + vy + "," + vz + ",versor=" + versor);

                        if (meshesLoaded[index].velocity != null) {
                            velocidad = meshesLoaded[index].velocity;
                        }
                        else {
                            velocidad = velocidadDefault;
                        }

                        scene.meshes[meshLoaded.meshes[j]].translate(versor, velocidad, BABYLON.Space.WORLD);
                    }
                }
            }

            if (loadCameraMovements)
            {
                movimientosDeCamara = obtenerGuion().cameraAnimation;
                loadCameraMovements = false;
            }

            //Movement and rotation of camera
            if (moveCamera && movimientosDeCamara != null && movimientosDeCamara[0] != null) {
                if (movimientosDeCamara[0].state == null) {
                    movimientosDeCamara[0].state = "RUNNING";

                    lastElapsedTime = new Date();
                    elapsedMilliseconds = 0;

                    //Position of Camera
                    positionCameraInitialX = centroDeCelda(movimientosDeCamara[0].from.position.camX);
                    positionCameraInitialY = movimientosDeCamara[0].from.position.camY;
                    positionCameraInitialZ = centroDeCelda(movimientosDeCamara[0].from.position.camZ);
                    camera.position = new BABYLON.Vector3(positionCameraInitialX, positionCameraInitialY, positionCameraInitialZ);
                    //console.log("Initial position: (%i, %i, %i)", positionCameraInitialX, positionCameraInitialY, positionCameraInitialZ);

                    vectorPositionCameraX = centroDeCelda(movimientosDeCamara[0].to.position.camX) - centroDeCelda(movimientosDeCamara[0].from.position.camX);
                    vectorPositionCameraY = movimientosDeCamara[0].to.position.camY - movimientosDeCamara[0].from.position.camY;
                    vectorPositionCameraZ = centroDeCelda(movimientosDeCamara[0].to.position.camZ) - centroDeCelda(movimientosDeCamara[0].from.position.camZ);
                    //console.log("Total Vector: (%i, %i, %i)", vectorPositionCameraX, vectorPositionCameraY, vectorPositionCameraZ);

                    //Target of Camera
                    targetCameraInitialX = centroDeCelda(movimientosDeCamara[0].from.target.camX);
                    targetCameraInitialY = movimientosDeCamara[0].from.target.camY;
                    targetCameraInitialZ = centroDeCelda(movimientosDeCamara[0].from.target.camZ);
                    camera.setTarget(new BABYLON.Vector3(targetCameraInitialX, targetCameraInitialY, targetCameraInitialZ));

                    vectorTargetCameraX = centroDeCelda(movimientosDeCamara[0].to.target.camX) - centroDeCelda(movimientosDeCamara[0].from.target.camX);
                    vectorTargetCameraY = movimientosDeCamara[0].to.target.camY - movimientosDeCamara[0].from.target.camY;
                    vectorTargetCameraZ = centroDeCelda(movimientosDeCamara[0].to.target.camZ) - centroDeCelda(movimientosDeCamara[0].from.target.camZ);
                }

                currentTime = new Date();

                elapsedMilliseconds = elapsedMilliseconds + (currentTime.getTime() - lastElapsedTime.getTime());

                if (elapsedMilliseconds > (movimientosDeCamara[0].duration * 1000)) {
                    movimientosDeCamara.shift();
                }
                else {
                    //Change the position of camera 
                    proportionTime = elapsedMilliseconds / (movimientosDeCamara[0].duration * 1000);
                    console.log("BEF: proportionTime: %f, elapsedMilliseconds: %i, duration: %i", proportionTime, elapsedMilliseconds, movimientosDeCamara[0].duration);
                    console.log("BEF: Camera position: (%i, %i, %i)", camera.position.x, camera.position.y, camera.position.z);
                    console.log("BEF: positionCameraInitialX + (vx * proportionTime): %i + (%i * %f)", positionCameraInitialX, vectorPositionCameraX, proportionTime);
                    camera.position = new BABYLON.Vector3(positionCameraInitialX + (vectorPositionCameraX * proportionTime), positionCameraInitialY + (vectorPositionCameraY * proportionTime), positionCameraInitialZ + (vectorPositionCameraZ * proportionTime));
                    console.log("AFT: Camera position: (%i, %i, %i)", camera.position.x, camera.position.y, camera.position.z);
                    console.log("");

                    //Change the target of camera
                    camera.setTarget(new BABYLON.Vector3(
                        targetCameraInitialX + (vectorTargetCameraX * proportionTime),
                        targetCameraInitialY + (vectorTargetCameraY * proportionTime),
                        targetCameraInitialZ + (vectorTargetCameraZ * proportionTime)
                    ));
                }
            }

        }

    </script>
</body>

</html>